-- -----------------------------------------------------
-- Procedures for Timeslots Package
-- -----------------------------------------------------

DELIMITER $$

-- -----------------------------------------------------
-- RI Tree Left/Right node finders.
-- -----------------------------------------------------
DROP PROCEDURE IF EXISTS `bm_rules_timeslot_left_nodes`$$

CREATE PROCEDURE `bm_rules_timeslot_left_nodes`(lower INT, upper INT)
BEGIN

  DECLARE treeHeight INT DEFAULT 0;
	DECLARE treeRoot INT DEFAULT 0; 
	DECLARE treeNode INT DEFAULT 0; 
	DECLARE searchStep INT DEFAULT 0;
	
	SET treeHeight  = ceil(LOG2((SELECT MAX(`slot_id`) FROM `slots`)+1));
	SET treeRoot    = power(2,(treeHeight-1)); 
	SET treeNode    = treeRoot;
	SET searchStep  =  treeNode / 2;

    -- holds a colletion of forkNodes 
   	DROP TEMPORARY TABLE IF EXISTS `timeslot_left_nodes_result`;
    CREATE TEMPORARY TABLE `timeslot_left_nodes_result` (`node` INT NOT NULL PRIMARY KEY)ENGINE=MEMORY; 
    
    
   -- descend from root node to lower
   myloop:WHILE searchStep >= 1 DO
  
    -- right node
    IF lower < treeNode THEN
      SET treeNode = treeNode - searchStep;
  
    -- left node
    ELSEIF lower > treeNode THEN
  
      INSERT INTO `timeslot_left_nodes_result`(node) VALUES(treeNode);
      SET treeNode = treeNode + searchStep;
  
    -- lower
    ELSE LEAVE myloop;
    END IF;  

    SET searchStep = searchStep / 2;
  
  END WHILE myloop;

END;
$$


DROP PROCEDURE IF EXISTS `bm_rules_timeslot_right_nodes`$$

CREATE PROCEDURE `bm_rules_timeslot_right_nodes`(lower INT, upper INT)
BEGIN

  DECLARE treeHeight INT DEFAULT 0;
	DECLARE treeRoot INT DEFAULT 0; 
	DECLARE treeNode INT DEFAULT 0; 
	DECLARE searchStep INT DEFAULT 0;
	
	SET treeHeight  = ceil(LOG2((SELECT MAX(`slot_id`) FROM `slots`)+1));
	SET treeRoot    = power(2,(treeHeight-1)); 
	SET treeNode    = treeRoot;
	SET searchStep  =  treeNode / 2;

    -- holds a colletion of forkNodes 
   	DROP TEMPORARY TABLE IF EXISTS `timeslot_right_nodes_result`;
    CREATE TEMPORARY TABLE `timeslot_right_nodes_result` (`node` INT NOT NULL PRIMARY KEY)ENGINE=MEMORY; 
    
    
   -- descend from root node to lower
   myloop:WHILE searchStep >= 1 DO
  
    -- right node
    IF upper > treeNode THEN
      SET treeNode = treeNode + searchStep;
  
    -- left node
    ELSEIF upper < treeNode THEN
  
      INSERT INTO `timeslot_right_nodes_result`(node) VALUES(treeNode);
      SET treeNode = treeNode - searchStep;
  
    -- lower
    ELSE LEAVE myloop;
    END IF;  

    SET searchStep = searchStep / 2;
  
  END WHILE myloop;

END;
$$


DROP PROCEDURE IF EXISTS `bm_rules_timeslot_nodes_top_left`$$

CREATE PROCEDURE `bm_rules_timeslot_nodes_top_left`(lower INT, upper INT)
BEGIN
    
    DECLARE treeHeight INT DEFAULT 0;
  	DECLARE treeRoot INT DEFAULT 0; 
  	DECLARE treeNode INT DEFAULT 0; 
  	DECLARE searchStep INT DEFAULT 0;
	
  	SET treeHeight  = ceil(LOG2((SELECT MAX(`slot_id`) FROM `slots`)+1));
  	SET treeRoot    = power(2,(treeHeight-1)); 
  	SET treeNode    = treeRoot;
  	SET searchStep  =  treeNode / 2;

    -- holds a colletion of forkNodes 
   	DROP TEMPORARY TABLE IF EXISTS `timeslot_nodes_top_left`;
    CREATE TEMPORARY TABLE `timeslot_nodes_top_left` (`node` INT NOT NULL PRIMARY KEY)ENGINE=MEMORY; 
    
    -- Descend from the root node to the fork node
    
    myloop:WHILE searchStep >= 1 DO
      
      IF treeNode < lower THEN
        -- this is in topLeft class if forkNode occurs before the lower bound.
        -- means this interval could intersect the search interval or could not
        -- at the lower bound.
         INSERT INTO timeslot_nodes_top_left (`node`) VALUES (treeNode);
         SET treeNode = treeNode + searchStep;
      ELSEIF upper < treeNode THEN
        -- above the forkNode keep going down  
        SET treeNode = treeNode - searchStep;
      ELSE 
        -- fork node
        LEAVE myloop;
      END IF;
    
      SET searchStep = searchStep / 2;
    
    END WHILE myloop;

END;
$$
